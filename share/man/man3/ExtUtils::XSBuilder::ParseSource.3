.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XSBuilder::ParseSource 3"
.TH XSBuilder::ParseSource 3 "2005-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ExtUtils::XSBuilder::ParseSource \- parse C source files
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
For more information, see ExtUtils::XSBuilder
.SS "extent_parser (o)"
.IX Subsection "extent_parser (o)"
Allows the user to call the Extent or Replace method of the parser to add 
new syntax rules. This is mainly useful to include expansions for 
preprocessor macros.
.SS "preprocess (o)"
.IX Subsection "preprocess (o)"
Allows the user to preprocess the source before it is given to the parser.
You may modify the source, which is given as first argument in place.
.SS "include_dirs (o)"
.IX Subsection "include_dirs (o)"
Returns a reference to the list of directories that should be searched for
include files which contain the functions, structures, etc. to be extracted.
.PP
Default: \f(CW\*(Aq.\*(Aq\fR
.SS "include_paths (o)"
.IX Subsection "include_paths (o)"
Returns a reference to a list of directories that are given as include
directories to the C compiler. This is mainly used to strip these directories
from filenames to convert absolute paths to relative paths.
.PP
Default: empty list (\f(CW\*(C`[]\*(C'\fR)
.SS "unwanted_includes (o)"
.IX Subsection "unwanted_includes (o)"
Returns a reference to a list of include files that should not be processed.
.PP
Default: empty list (\f(CW\*(C`[]\*(C'\fR)
.SS "sort_includes (o, include_list)"
.IX Subsection "sort_includes (o, include_list)"
Passed an array ref of include files, it allows the user to define the sort
order, so includes are processed correctly.
.PP
Default: return the passed array reference.
.SS "find_includes (o)"
.IX Subsection "find_includes (o)"
Returns a list of include files to be processed.
.PP
Default: search directories given by \f(CW\*(C`include_dirs\*(C'\fR for all files and build a
list of include files. All files starting with a word matched by 
\&\f(CW\*(C`unwanted_includes\*(C'\fR are not included in the list.
.SS "handle_define (o)"
.IX Subsection "handle_define (o)"
Passed a hash ref with the definition of a define, may modify it.
Return false to discard it, return true to keep it.
.PP
Default: \f(CW1\fR
.SS "handle_enum (o)"
.IX Subsection "handle_enum (o)"
Passed a hash ref with the definition of a enum value, may modify it.
Return false to discard it, return true to keep it.
.PP
Default: \f(CW1\fR
.SS "handle_struct (o)"
.IX Subsection "handle_struct (o)"
Passed a hash ref with the definition of a struct, may modify it.
Return false to discard it, return true to keep it.
.PP
Default: \f(CW1\fR
.SS "handle_function (o)"
.IX Subsection "handle_function (o)"
Passed a hash ref with the definition of a function, may modify it.
Return false to discard it, return true to keep it.
.PP
Default: \f(CW1\fR
.SS "handle_callback (o)"
.IX Subsection "handle_callback (o)"
Passed a hash ref with the definition of a callback, may modify it.
Return false to discard it, return true to keep it.
.PP
Default: \f(CW1\fR
.SS "package (o)"
.IX Subsection "package (o)"
Return package name for tables
.PP
Default: \f(CW\*(AqMY\*(Aq\fR
.SS "targetdir (o)"
.IX Subsection "targetdir (o)"
Return name of target directory where to write tables
.PP
Default: \f(CW\*(Aq./xsbuilder/tables\*(Aq\fR
.SS "run"
.IX Subsection "run"
Call this class method to parse your source. Before you can do so you must
provide a class that overrides the defaults in
ExtUtils::XSBuilder::ParseSource. After that you scan the source files with
.PP
.Vb 1
\&    MyClass \-> run ;
.Ve
