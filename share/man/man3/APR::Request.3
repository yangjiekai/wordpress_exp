.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Request 3"
.TH Request 3 "2019-02-21" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
APR::Request \- wrapper for libapreq2's module/handle API.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use APR::Request;
\&
\&  $req = APR::Request::Custom\->handle($pool,
\&                                      "foo=arg1&bar=arg2",
\&                                      "apache=quux",
\&                                       $parser, 1e6, $bb);
\&  $param = $req\->param("foo");
\&  $cookie = $req\->jar("apache");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`APR::Request\*(C'\fR module provides the base methods
for interfacing with libapreq2's module \s-1API\s0.  It also provides
a few utility functions and constants.
.PP
This manpage documents version 2.13
of the APR::Request, APR::Request::Custom,
APR::Request::Cookie::Table, and
APR::Request::Param::Table packages.
.SH "METHODS"
.IX Header "METHODS"
APR::Request::Custom \- derived from APR::Request.
.SS "handle"
.IX Subsection "handle"
.Vb 6
\&    APR::Request::Custom\->handle($pool,
\&                                 $query_string,
\&                                 $cookie_header,
\&                                 $parser,
\&                                 $read_limit,
\&                                 $brigade)
.Ve
.PP
Creates a new APR::Request::Custom object.  The \f(CW$query_string\fR
and \f(CW$cookie_headers\fR are immediately parsed into the \f(CW\*(C`args\*(C'\fR and
\&\f(CW\*(C`jar\*(C'\fR tables.  The \f(CW$parser\fR is an APR::Request::Parser object
which is invoked when fetching \f(CW\*(C`body\*(C'\fR entries from the \f(CW$brigade\fR.
The \f(CW$read_limit\fR represents the maximum number of bytes this handle
may feed into the parser.
.SH "METHODS"
.IX Header "METHODS"
APR::Request
.SS "pool"
.IX Subsection "pool"
.Vb 1
\&    $req\->pool()
.Ve
.PP
Returns the APR::Pool object associated to this handle.
.SS "bucket_alloc"
.IX Subsection "bucket_alloc"
.Vb 1
\&    $req\->bucket_alloc()
.Ve
.PP
Returns the APR::BucketAlloc object associated to this handle.
.SS "jar_status"
.IX Subsection "jar_status"
.Vb 1
\&    $req\->jar_status()
.Ve
.PP
Returns the final status code of the handle's cookie header parser.
.SS "args_status"
.IX Subsection "args_status"
.Vb 1
\&    $req\->args_status()
.Ve
.PP
Returns the final status code of the handle's query-string parser.
.SS "body_status"
.IX Subsection "body_status"
.Vb 1
\&    $req\->body_status()
.Ve
.PP
Returns the final status code of the handle's body parser.
.SS "param_status"
.IX Subsection "param_status"
.Vb 1
\&    $req\->param_status()
.Ve
.PP
Returns \f(CW\*(C`($req\->args_status, $req\->body_status)\*(C'\fR in list
context; otherwise returns \f(CW\*(C`$req\->args_status || $req\->body_status\*(C'\fR.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&    $req\->parse()
.Ve
.PP
Parses the jar, args, and body tables. Returns
\&\f(CW\*(C`$req\->jar_status, $req\->args_status, $req\->body_status\*(C'\fR.
.PP
.Vb 5
\&    @status = $req\->parse;
\&    ok @status == 3;
\&    ok $status[0] == $req\->jar_status;
\&    ok $status[1] == $req\->args_status;
\&    ok $status[2] == $req\->body_status;
.Ve
.SS "jar"
.IX Subsection "jar"
.Vb 2
\&    $req\->jar()
\&    $req\->jar($key)
.Ve
.PP
With no arguments, this method returns a tied APR::Request::Cookie::Table
object (or undef if the \*(L"Cookie\*(R" header is absent) in scalar context, or 
the names (in order, with repetitions) of all the parsed cookies.
.PP
With the \f(CW$key\fR argument, in scalar context this method fetches the first
matching cookie.  In list context it returns all matching cookies.
The returned cookies are the values as they appeared in the incoming
Cookie header.
.PP
\&\fIjar()\fR will throw an APR::Request::Error object whenever \fIjar_status()\fR 
is non-zero and the return value is potentially invalid (eg
\&\f(CW\*(C`scalar $req\->jar($key)\*(C'\fR will not die if the desired cookie
was successfully parsed).
.PP
.Vb 4
\&    $jar = $req\->jar;
\&    @cookie_names = $req\->jar;
\&    ok $jar\->isa("APR::Request::Cookie::Table");
\&    ok shift @cookie_names eq $_ for keys %$jar;
\&
\&    $cookie = $req\->jar("apache");
\&    @cookies = $req\->jar("apache");
.Ve
.SS "args"
.IX Subsection "args"
.Vb 2
\&    $req\->args()
\&    $req\->args($key)
.Ve
.PP
With no arguments, this method returns a tied APR::Request::Param::Table
object (or undef if the query string is absent) in scalar context, or the 
names (in order, with repetitions) of all the parsed query-string arguments.
.PP
With the \f(CW$key\fR argument, in scalar context this method fetches the first
matching query-string arg.  In list context it returns all matching args.
.PP
\&\fIargs()\fR will throw an APR::Request::Error object whenever \fIargs_status()\fR 
is non-zero and the return value is potentially invalid (eg
\&\f(CW\*(C`scalar $req\->args($key)\*(C'\fR will not die if the desired query argument
was successfully parsed).
.PP
.Vb 4
\&   $args = $req\->args;
\&   @arg_names = $req\->args;
\&   ok $args\->isa("APR::Request::Param::Table");
\&   ok shift @arg_names eq $_ for keys %$args;
\&
\&   $foo = $req\->args("foo");
\&   @bar = $req\->args("bar");
.Ve
.SS "body"
.IX Subsection "body"
.Vb 2
\&    $req\->body()
\&    $req\->body($key)
.Ve
.PP
With no arguments, this method returns a tied APR::Request::Param::Table
object (or undef if the request body is absent) in scalar context, or the 
names (in order, with repetitions) of all the parsed cookies.
.PP
With the \f(CW$key\fR argument, in scalar context this method fetches the first
matching body param.  In list context it returns all matching body params.
.PP
\&\fIbody()\fR will throw an APR::Request::Error object whenever \fIbody_status()\fR 
is non-zero and the return value is potentially invalid (eg 
\&\f(CW\*(C`scalar $req\->body($key)\*(C'\fR will not die if the desired body param was
successfully parsed).
.PP
.Vb 4
\&    $body = $req\->body;
\&    @body_names = $req\->body;
\&    ok $body\->isa("APR::Request::Param::Table");
\&    ok shift @body_names eq $_ for keys %$body;
\&
\&    $alpha = $req\->body("alpha");
\&    @beta = $req\->body("beta");
.Ve
.SS "param"
.IX Subsection "param"
.Vb 2
\&    $req\->param()
\&    $req\->param($key)
.Ve
.PP
With no arguments, this method returns a tied APR::Request::Param::Table
object (or undef, if the query string and request body are absent) in scalar
context, or the names (in order, with repetitions) of all the incoming
(args + body) params.
.PP
With the \f(CW$key\fR argument, in scalar context this method fetches the first
matching param.  In list context it returns all matching params.
.PP
\&\fIparam()\fR will throw an APR::Request::Error object whenever \fIparam_status()\fR 
is non-zero and the return value is potentially invalid (eg 
\&\f(CW\*(C`scalar $req\->param($key)\*(C'\fR will not die if the desired param 
was successfully parsed).
.PP
.Vb 4
\&    $param = $req\->param;
\&    @param_names = $req\->param;
\&    ok $param\->isa("APR::Request::Param::Table");
\&    ok shift @param_names eq $_ for keys %$param;
\&
\&    $foo = $req\->param("foo");
\&    @foo = $req\->param("foo");
.Ve
.SS "upload"
.IX Subsection "upload"
.Vb 2
\&    $req\->upload()
\&    $req\->upload($key)
.Ve
.PP
With no arguments, this method returns a tied APR::Request::Param::Table
object (or undef if the request body is absent) in scalar context (whose
entries are APR::Request::Param objects), or the names (in order, with 
repetitions) of all the incoming uploads.
.PP
With the \f(CW$key\fR argument, in scalar context this method fetches the first
matching upload.  In list context it returns all matching uploads.  The return
values are APR::Request::Param objects.
.PP
\&\fIupload()\fR will throw an APR::Request::Error object whenever \fIbody_status()\fR 
is non-zero.
.PP
.Vb 5
\&    $uploads = $req\->upload;
\&    @upload_names = $req\->upload;
\&    ok $uploads\->isa("APR::Request::Param::Table");
\&    ok shift @upload_names eq $_ for keys %$uploads;
\&    ok $_\->upload for values %$uploads;
\&
\&    $up = $req\->upload("beta");
\&    @ups = $req\->upload("beta");
\&    ok $_\->isa("APR::Request::Param") for $up, @ups;
\&    ok $_\->upload for $up, @ups;
.Ve
.SS "read_limit"
.IX Subsection "read_limit"
.Vb 2
\&    $req\->read_limit()
\&    $req\->read_limit($set)
.Ve
.PP
Get/set the read limit, which controls the total amount of
bytes that can be fed to the current parser.
.SS "brigade_limit"
.IX Subsection "brigade_limit"
.Vb 2
\&    $req\->brigade_limit()
\&    $req\->brigade_limit($set)
.Ve
.PP
Get/set the brigade_limit for the current parser.  This limit
determines how many bytes of a file upload that the parser may
spool into main memory.  Uploads exceeding this limit are written
directly to disk.
.SS "temp_dir"
.IX Subsection "temp_dir"
.Vb 2
\&    $req\->temp_dir()
\&    $req\->temp_dir($set)
.Ve
.PP
Get/set the spool directory for uploads which exceed the configured
brigade_limit.
.SS "disable_uploads"
.IX Subsection "disable_uploads"
.Vb 1
\&    $req\->disable_uploads()
.Ve
.PP
Engage the disable_uploads hook for this request.
.SS "upload_hook"
.IX Subsection "upload_hook"
.Vb 1
\&    $req\->upload_hook($callback)
.Ve
.PP
Add an upload hook callback for this request.  The
arguments to the \f(CW$callback\fR sub are ($upload, \f(CW$new_data\fR).
.SS "import"
.IX Subsection "import"
Exports a list of subs into the caller's package.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
APR::Request
.SS "encode"
.IX Subsection "encode"
.Vb 1
\&    encode($string)
.Ve
.PP
Exportable sub which returns the url-encoded form of \f(CW$string\fR.
.SS "decode"
.IX Subsection "decode"
.Vb 1
\&    decode($string)
.Ve
.PP
Exportable sub which returns the url-decoded form of \f(CW$string\fR.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
APR::Request
.PP
If the instances of your subclass are hash references then you can actually
inherit from APR::Request as long as the APR::Request object is stored in
an attribute called \*(L"r\*(R" or \*(L"_r\*(R". (The APR::Request class effectively does the
delegation for you automagically, as long as it knows where to find the
APR::Request object to delegate to.)  For example:
.PP
.Vb 7
\&        package MySubClass;
\&        use APR::Request::Custom;
\&        our @ISA = qw(APR::Request);
\&        sub new {
\&            my($class, @args) = @_;
\&            return bless { r => APR::Request::Custom\->handle(@args) }, $class;
\&        }
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Vb 1
\&  APR::Request::Cookie::Table \- read\-only version of APR::Table.
.Ve
.PP
Tables in this class normally arise from calls to
\&\f(CW\*(C`APR::Request::jar()\*(C'\fR.
.SS "cookie_class"
.IX Subsection "cookie_class"
.Vb 2
\&    $table\->cookie_class()
\&    $table\->cookie_class($set)
.Ve
.PP
Get/set the class each table element is blessed into during a
get or \s-1FETCH\s0 call.  If defined, the class must be derived
from APR::Request::Cookie.  When called with \f(CW$set\fR, it returns
the \f(CW$table\fR.  Otherwise it returns the name of the current class,
or undef if no cookie class is defined.
.SS "get"
.IX Subsection "get"
.Vb 1
\&    $table\->get($key)
.Ve
.PP
Same as \s-1FETCH\s0.
.SS "\s-1FETCH\s0"
.IX Subsection "FETCH"
.Vb 1
\&    $table\->FETCH($key)
.Ve
.PP
In scalar context, this returns the first value matching
\&\f(CW$key\fR (note: see \s-1NEXTKEY\s0 for additional notes).  The match
is always case-insensitive.  In list context, this returns
all matching values.  Note: the type of the return values
depends on the table's current cookie_class.
.SS "\s-1EXISTS\s0"
.IX Subsection "EXISTS"
Synonym for \f(CW\*(C`defined\*(C'\fR; these tables are not
allowed to contain undefined values. Since these
are constant tables, they don't autovivify either.
.SS "\s-1FIRSTKEY\s0"
.IX Subsection "FIRSTKEY"
.Vb 1
\&    $table\->FIRSTKEY()
.Ve
.PP
Returns the first key in the table.
.SS "\s-1NEXTKEY\s0"
.IX Subsection "NEXTKEY"
.Vb 1
\&    $table\->NEXTKEY()
.Ve
.PP
Returns the next key in the table.  For perl 5.8+,
if the key is multivalued, a subsequent \s-1FETCH\s0 on
this key will return the corresponding value, until
either \s-1NEXTKEY\s0 or \s-1FIRSTKEY\s0 is invoked again.  For
perl 5.6, \s-1FETCH\s0 always returns the first value.
.SS "do"
.IX Subsection "do"
.Vb 1
\&    $table\->do($callback, @keys)
.Ve
.PP
Same as APR::Table::do; iterates over the table
calling \f(CW$callback\fR\->($key, \f(CW$value\fR) for each matching
\&\f(CW@keys\fR.  If \f(CW@keys\fR is empty, this iterates over the
entire table.
.PP
Note: The type of \f(CW$value\fR inserted into the callback
depends on the table's current cookie_class.
.SH "METHODS"
.IX Header "METHODS"
APR::Request::Param::Table
.SS "param_class"
.IX Subsection "param_class"
.Vb 2
\&    $table\->param_class()
\&    $table\->param_class($set)
.Ve
.PP
Get/set the class each table element is blessed into during a
\&\f(CW\*(C`get\*(C'\fR or \f(CW\*(C`FETCH\*(C'\fR call.  If defined, the class must be derived
from APR::Request::Param.  When called with \f(CW$set\fR, it returns
the \f(CW$table\fR.  Otherwise it returns the name of the current class,
or undef if no param class is defined.
.SS "get"
.IX Subsection "get"
.Vb 1
\&    $table\->get($key)
.Ve
.PP
Same as \s-1FETCH\s0.
.SS "\s-1FETCH\s0"
.IX Subsection "FETCH"
.Vb 1
\&    $table\->FETCH($key)
.Ve
.PP
In scalar context, this returns the first value matching
\&\f(CW$key\fR (see \s-1NEXTKEY\s0 for additional notes on this).  The match
is always case-insensitive.  In list context, this returns
all matching values.  Note: the type of the return values
depends on the table's current param_class.
.SS "\s-1EXISTS\s0"
.IX Subsection "EXISTS"
Synonym for \f(CW\*(C`defined\*(C'\fR; these tables are not
allowed to contain undefined values. Since these
are constant tables, they don't autovivify either.
.SS "\s-1NEXTKEY\s0"
.IX Subsection "NEXTKEY"
.Vb 1
\&    $table\->NEXTKEY()
.Ve
.PP
Returns the next key in the table.  For perl 5.8+,
if the key is multivalued, a subsequent \s-1FETCH\s0 on
this key will return the corresponding value, until
either \s-1NEXTKEY\s0 or \s-1FIRSTKEY\s0 is invoked again.  For
perl 5.6, \s-1FETCH\s0 always returns the first value.
.SS "\s-1FIRSTKEY\s0"
.IX Subsection "FIRSTKEY"
.Vb 1
\&    $table\->FIRSTKEY()
.Ve
.PP
Returns the first key in the table.
.SS "do"
.IX Subsection "do"
.Vb 1
\&    $table\->do($callback, @keys)
.Ve
.PP
Same as APR::Table::do; iterates over the table
calling \f(CW$callback\fR\->($key, \f(CW$value\fR) for each matching
\&\f(CW@keys\fR.  If \f(CW@keys\fR is empty, this iterates over the
entire table.
.PP
Note: The type of \f(CW$value\fR inserted into the callback
depends on the table's current value_class.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
APR::Request::Error, APR::Request::Param,
APR::Request::Cookie, APR::Request::Parser
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 6
\&  Licensed to the Apache Software Foundation (ASF) under one or more
\&  contributor license agreements.  See the NOTICE file distributed with
\&  this work for additional information regarding copyright ownership.
\&  The ASF licenses this file to You under the Apache License, Version 2.0
\&  (the "License"); you may not use this file except in compliance with
\&  the License.  You may obtain a copy of the License at
\&
\&      http://www.apache.org/licenses/LICENSE\-2.0
\&
\&  Unless required by applicable law or agreed to in writing, software
\&  distributed under the License is distributed on an "AS IS" BASIS,
\&  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
\&  See the License for the specific language governing permissions and
\&  limitations under the License.
.Ve
